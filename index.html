<script>
    // Leaflet Marker Slide Plugin
    (function(){var t=L.Marker.prototype.setLatLng;L.Marker.include({slideTo:function(e,i){var n=this;return n._slideToUntil=performance.now()+(i.duration||1e3),n._slideToFromLatLng=n.getLatLng(),n._slideToToLatLng=L.latLng(e),n._slideToDuration=i.duration||1e3,n._slideToFrame=requestAnimationFrame(function t(e){var i=performance.now(),r=(i-n._slideToUntil+n._slideToDuration)/n._slideToDuration;r>1&&(r=1),n.setLatLng([n._slideToFromLatLng.lat+(n._slideToToLatLng.lat-n._slideToFromLatLng.lat)*r,n._slideToFromLatLng.lng+(n._slideToToLatLng.lng-n._slideToFromLatLng.lng)*r]),r<1?n._slideToFrame=requestAnimationFrame(t):n.fire("moveend")}),n}})}).call(this);

    // Vercel Proxy Path
    const PROXY = '/api/metlink?url='; 
    const URLS = { 
        pos: 'https://api.opendata.metlink.org.nz/v1/gtfs-rt/vehiclepositions', 
        routes: 'https://api.opendata.metlink.org.nz/v1/gtfs/routes', 
        trips: 'https://api.opendata.metlink.org.nz/v1/gtfs/trips', 
        shapes: 'https://api.opendata.metlink.org.nz/v1/gtfs/shapes', 
        stops: 'https://api.opendata.metlink.org.nz/v1/gtfs/stops',
        preds: 'https://api.opendata.metlink.org.nz/v1/stop-predictions' 
    };
    
    const map = L.map('map', { zoomControl: false }).setView([-41.2865, 174.7762], 13);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r.png}').addTo(map);

    map.createPane('linePane').style.zIndex = 400;
    map.createPane('stopsPane').style.zIndex = 500;
    map.createPane('vehiclesPane').style.zIndex = 600;

    let markers = {}, routeDetails = {}, stopNameCache = {}, currentRouteLine = null, stopMarkers = L.layerGroup().addTo(map);
    let currentlyHighlightedRoute = null, hiddenTypes = new Set(), isDragging = false;
    const OCC_MAP = { 0: "Unknown", 1: "Seats Available", 2: "Standing Room", 3: "Full" };

    map.on('movestart', () => { isDragging = true; });
    map.on('moveend', () => { setTimeout(() => { isDragging = false; }, 100); });
    map.on('click', (e) => { 
        if (!isDragging && e.originalEvent && e.originalEvent.target.id === 'map') { clearSelection(); } 
    });

    async function getStopName(stopId) {
        if (!stopId) return "Approaching Route Start";
        if (stopNameCache[stopId]) return stopNameCache[stopId];
        try {
            const res = await fetch(PROXY + encodeURIComponent(`${URLS.stops}?stop_id=${stopId}`));
            const data = await res.json();
            if (data && data.length > 0) {
                stopNameCache[stopId] = data[0].stop_name;
                return data[0].stop_name;
            }
        } catch(e) {}
        return `Stop ${stopId}`;
    }

    async function drawStops(routeId, routeShortName) {
        stopMarkers.clearLayers();
        try {
            const res = await fetch(PROXY + encodeURIComponent(`${URLS.stops}?route_id=${routeId}`));
            const data = await res.json();
            data.forEach(stop => {
                stopNameCache[stop.stop_id] = stop.stop_name;
                const hitbox = L.circleMarker([stop.stop_lat, stop.stop_lon], { radius: 10, stroke: false, fillOpacity: 0, pane: 'stopsPane' }).addTo(stopMarkers);
                L.circleMarker([stop.stop_lat, stop.stop_lon], { radius: 5, fillColor: "#CDDC00", color: "#002A3A", weight: 2, fillOpacity: 1, interactive: false, pane: 'stopsPane' }).addTo(stopMarkers);
                
                hitbox.on('click', async () => {
                    hitbox.bindPopup(`<div class="stop-popup"><b>${stop.stop_name}</b><br><div id="live-status-${stop.stop_id}">Loading...</div><span class="fare-badge">ZONE ${stop.zone_id || 'N/A'}</span></div>`).openPopup();
                    const html = await getStopStatus(stop.stop_id, routeShortName);
                    const el = document.getElementById(`live-status-${stop.stop_id}`);
                    if (el) el.innerHTML = html;
                });
            });
        } catch(e) {}
    }

    async function getStopStatus(stopId, routeShortName) {
        try {
            const res = await fetch(PROXY + encodeURIComponent(`${URLS.preds}?stop_id=${stopId}`));
            const data = await res.json();
            const pred = data.arrivals.find(a => a.service_id === routeShortName);
            if (!pred) return "No live data";
            const statusClass = pred.status === 'delayed' ? 'status-delayed' : 'status-on-time';
            return `<div class="status-pill ${statusClass}">${pred.status.toUpperCase()}</div>`;
        } catch (e) { return "Unavailable"; }
    }

    async function drawRouteShape(routeId, color) {
        try {
            const tRes = await fetch(PROXY + encodeURIComponent(`${URLS.trips}?route_id=${routeId}`));
            const trips = await tRes.json();
            const uniqueShapeIds = [...new Set(trips.map(t => t.shape_id))].filter(s => s);
            if (currentRouteLine) map.removeLayer(currentRouteLine);
            currentRouteLine = L.featureGroup().addTo(map);
            for (const shapeId of uniqueShapeIds) {
                const sRes = await fetch(PROXY + encodeURIComponent(`${URLS.shapes}?shape_id=${encodeURIComponent(shapeId)}`));
                const sData = await sRes.json();
                const points = sData.sort((a,b)=>a.shape_pt_sequence-b.shape_pt_sequence).map(p => [p.shape_pt_lat, p.shape_pt_lon]);
                L.polyline(points, { color, weight: 6, opacity: 0.7, lineJoin: 'round', pane: 'linePane' }).addTo(currentRouteLine);
            }
            if (uniqueShapeIds.length > 0) map.fitBounds(currentRouteLine.getBounds(), { padding: [50, 50] });
        } catch(e) {}
    }

    window.searchRoute = async function() {
        const query = document.getElementById('routeInput').value.trim().toUpperCase();
        if (!query) return;
        currentlyHighlightedRoute = query;
        const routeMeta = Object.values(routeDetails).find(r => r.short === query);
        if (routeMeta) {
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('p-route').innerText = `Route ${routeMeta.short}`;
            document.getElementById('p-desc').innerText = routeMeta.long;
            drawRouteShape(routeMeta.id, routeMeta.bgColor);
            drawStops(routeMeta.id, routeMeta.short);
        }
        refreshVisibility();
    };

    async function fetchPositions() {
        try {
            const response = await fetch(PROXY + encodeURIComponent(`${URLS.pos}?t=${Date.now()}`));
            const buffer = await response.arrayBuffer();
            
            // Decodes the Protobuf binary data
            const feed = FeedMessage.read(new Pbf(new Uint8Array(buffer)));
            console.log(`Update: ${feed.entity.length} vehicles found.`);
            
            const activeIds = new Set();
            for (const entity of feed.entity) {
                const v = entity.vehicle; if (!v) continue;
                const id = String(v.vehicle.id);
                const details = routeDetails[v.trip.route_id] || { short: "??", bgColor: "#002A3A", textColor: "#fff" };
                activeIds.add(id);
                
                let iconUrl = 'https://www.metlink.org.nz/assets/Icons/Bus.svg';
                if (['HVL','KPL','JVL','MEL','WRL'].includes(details.short)) iconUrl = 'https://www.metlink.org.nz/assets/Icons/Train.svg';
                if (details.short === 'CCL') iconUrl = 'https://www.metlink.org.nz/assets/Icons/Cable-Car.svg';
                if (details.short === 'WHF') iconUrl = 'https://www.metlink.org.nz/assets/Icons/Ferry.svg';
                
                const occName = OCC_MAP[v.occupancy_status || 0];
                const popupBase = (stopName) => `<div style="font-family:var(--gent-font);"><b>Route ${details.short}</b><br>Next: ${stopName}<br><small>${occName}</small></div>`;

                if (markers[id]) {
                    markers[id].slideTo([v.position.latitude, v.position.longitude], { duration: 4500 });
                } else {
                    markers[id] = L.marker([v.position.latitude, v.position.longitude], {
                        icon: L.divIcon({ 
                            className: 'vehicle-wrapper', 
                            html: `<div class="vehicle-ring" style="--route-color: ${details.bgColor}"><img src="${iconUrl}"></div>`, 
                            iconSize: [28,28], iconAnchor: [14,14] 
                        }),
                        pane: 'vehiclesPane', iconFile: iconUrl, routeShortName: details.short, routeColors: { bg: details.bgColor, text: details.textColor }, occText: occName
                    }).addTo(map).bindPopup(popupBase("Loading..."));
                    
                    markers[id].on('click', async () => {
                        const name = await getStopName(v.stop_id);
                        markers[id].setPopupContent(popupBase(name));
                    });
                }
                updateLabel(markers[id]);
            }

            Object.keys(markers).forEach(mid => { if (!activeIds.has(mid)) { map.removeLayer(markers[mid]); delete markers[mid]; } });
            refreshVisibility();
            document.getElementById('id-count').innerText = activeIds.size;
        } catch(e) { console.error("Position Error:", e); }
    }

    function updateLabel(marker) {
        if (currentlyHighlightedRoute === marker.options.routeShortName) {
            const content = `${marker.options.routeShortName}`;
            if (!marker.getTooltip()) marker.bindTooltip(content, { permanent: true, direction: 'top', className: 'route-tooltip', offset: [0,-15] }).openTooltip();
            const el = marker.getTooltip().getElement();
            if (el) { el.style.backgroundColor = marker.options.routeColors.bg; el.style.color = marker.options.routeColors.text; }
        } else if (marker.getTooltip()) marker.unbindTooltip();
    }

    window.toggleFilter = function(icon, el) {
        hiddenTypes.has(icon) ? hiddenTypes.delete(icon) : hiddenTypes.add(icon);
        el.classList.toggle('inactive'); refreshVisibility();
    };

    window.handleAutocomplete = function() {
        const val = document.getElementById('routeInput').value.trim().toUpperCase();
        const suggs = document.getElementById('suggestions');
        suggs.innerHTML = '';
        if (!val) { suggs.style.display = 'none'; return; }
        const matches = Object.values(routeDetails).filter(r => r.short.startsWith(val)).slice(0, 5);
        if (matches.length > 0) {
            suggs.style.display = 'block';
            matches.forEach(m => {
                const div = document.createElement('div'); div.className = 'suggestion-item'; div.innerText = `${m.short} - ${m.long}`;
                div.onclick = () => { document.getElementById('routeInput').value = m.short; suggs.style.display = 'none'; searchRoute(); };
                suggs.appendChild(div);
            });
        } else { suggs.style.display = 'none'; }
    };

    function refreshVisibility() {
        Object.values(markers).forEach(m => {
            if (hiddenTypes.has(m.options.iconFile) || (currentlyHighlightedRoute && m.options.routeShortName !== currentlyHighlightedRoute)) map.removeLayer(m);
            else { if (!map.hasLayer(m)) map.addLayer(m); updateLabel(m); }
        });
    }

    window.clearSelection = function() {
        if (currentRouteLine) map.removeLayer(currentRouteLine);
        stopMarkers.clearLayers();
        currentlyHighlightedRoute = null;
        document.getElementById('routeInput').value = "";
        document.getElementById('info-panel').style.display = 'none';
        refreshVisibility();
    };

    async function init() { 
        try {
            const res = await fetch(PROXY + encodeURIComponent(URLS.routes));
            const data = await res.json();
            data.forEach(r => { routeDetails[r.route_id] = { id: r.route_id, short: r.route_short_name, long: r.route_long_name, bgColor: r.route_color ? `#${r.route_color}` : '#002A3A', textColor: r.route_text_color ? `#${r.route_text_color}` : '#fff' }; });
            fetchPositions(); setInterval(fetchPositions, 5000); 
        } catch(e) { console.error("Init Error:", e); }
    }
    init();
</script>
